-- Ensure auth.users has raw_user_meta_data and recreate handle_user_type trigger safely

-- Add column if missing
ALTER TABLE IF EXISTS auth.users
  ADD COLUMN IF NOT EXISTS raw_user_meta_data JSONB DEFAULT '{}'::jsonb;

-- Recreate the handle_user_type function so it runs safely now that column exists
CREATE OR REPLACE FUNCTION public.handle_user_type()
RETURNS TRIGGER AS $$
DECLARE
    user_type text;
BEGIN
    SELECT
        CASE
            WHEN EXISTS (SELECT 1 FROM public.farmers WHERE user_id = NEW.id) THEN 'farmer'
            WHEN EXISTS (SELECT 1 FROM public.vets WHERE user_id = NEW.id) THEN 'vet'
            ELSE COALESCE(NEW.raw_user_meta_data->>'user_type', 'unassigned')
        END INTO user_type;

    NEW.raw_user_meta_data =
        COALESCE(NEW.raw_user_meta_data, '{}'::jsonb) ||
        jsonb_build_object('user_type', user_type);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Ensure trigger exists and is attached AFTER we have the column and function
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  BEFORE INSERT OR UPDATE ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_user_type();

-- Populate existing rows that are missing a user_type
UPDATE auth.users
SET raw_user_meta_data = COALESCE(raw_user_meta_data, '{}'::jsonb) ||
  jsonb_build_object('user_type',
    CASE
      WHEN EXISTS (SELECT 1 FROM public.farmers WHERE user_id = auth.users.id) THEN 'farmer'
      WHEN EXISTS (SELECT 1 FROM public.vets WHERE user_id = auth.users.id) THEN 'vet'
      ELSE 'unassigned'
    END
  )
WHERE COALESCE(raw_user_meta_data->>'user_type','') = '';
